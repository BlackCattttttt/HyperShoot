using System.Collections;
using System.Collections.Generic;
using UnityEngine;
namespace HyperShoot.Player
{
    public class FPCharacterController : FPController
    {
        // general
        protected Vector3 m_FixedPosition = Vector3.zero;       // exact position. updates at a fixed interval and is used for gameplay
        protected Vector3 m_SmoothPosition = Vector3.zero;      // smooth position. updates as often as possible and is only used for the camera
        public Vector3 SmoothPosition { get { return m_SmoothPosition; } }  // a version of the controller position calculated in 'Update' to get smooth camera motion
        public Vector3 Velocity { get { return characterController.velocity; } }
        protected bool m_IsFirstPerson = true;

        public float GroundAngle { get { return Vector3.Angle(m_GroundHit.normal, Vector3.up); } }

        // motor
        public float MotorAcceleration = 0.18f;
        public float MotorDamping = 0.17f;
        public float MotorBackwardsSpeed = 0.65f;
        public float MotorAirSpeed = 0.35f;
        public float MotorSlopeSpeedUp = 1.0f;
        public float MotorSlopeSpeedDown = 1.0f;
        protected Vector3 m_MoveDirection = Vector3.zero;
        protected float m_SlopeFactor = 1.0f;
        protected Vector3 m_MotorThrottle = Vector3.zero;
        protected float m_MotorAirSpeedModifier = 1.0f;
        protected float m_CurrentAntiBumpOffset = 0.0f;

        protected Vector3 m_PredictedPos = Vector3.zero;

        protected override void Start()
        {
            base.Start();

            SetPosition(Transform.position);
        }
        protected override void Update()
        {

            base.Update();

            // simulate high-precision movement for smoothest possible camera motion
            SmoothMove();

            // TIP: uncomment either of these lines to debug print the
            // speed of the character controller
            //Debug.Log(Velocity.magnitude);		// speed in meters per second
            //Debug.Log(Controller.Velocity.sqrMagnitude);	// speed as used by the camera bob

        }
        protected override void FixedUpdate()
        {

            if (Time.timeScale == 0.0f)
                return;

            // convert user input to motor throttle
            UpdateMotor();

            // apply motion generated by tapping or holding the jump button
            //UpdateJump();

            // handle external forces like gravity, explosion shockwaves or wind
            //UpdateForces();

            // apply sliding in slopes
            //UpdateSliding();

            // detect when player falls, slides or gets pushed out of control
            //UpdateOutOfControl();

            // update controller position based on current motor- & external forces
            FixedMove();

            // respond to environment collisions that may have happened during the move
            //UpdateCollisions();

            // move and rotate player along with rigidbodies & moving platforms
            //UpdatePlatformMove();

            // store final position and velocity for next frame's physics calculations
            UpdateVelocity();

        }

        protected virtual void UpdateMotor()
        {
            UpdateThrottleWalk();
            // snap super-small values to zero to avoid floating point issues
            m_MotorThrottle = fp_MathUtility.SnapToZero(m_MotorThrottle);

        }
        protected virtual void UpdateThrottleWalk()
        {

            // if on the ground, make movement speed dependent on ground slope
            UpdateSlopeFactor();

            // update air speed modifier
            // (at 1.0, this will completely prevent the controller from altering
            // its trajectory while in the air, and will disable motor damping)
            m_MotorAirSpeedModifier = (m_Grounded ? 1.0f : MotorAirSpeed);

            // convert horizontal input to forces in the motor
            m_MotorThrottle +=
                ((Player.InputMoveVector.Get().y > 0) ? Player.InputMoveVector.Get().y : // if moving forward or sideways: use normal speed
                (Player.InputMoveVector.Get().y * MotorBackwardsSpeed))     // if moving backwards: apply backwards-modifier
                * (Transform.TransformDirection(Vector3.forward * (MotorAcceleration * 0.1f) * m_MotorAirSpeedModifier) * m_SlopeFactor);
            m_MotorThrottle += Player.InputMoveVector.Get().x * (Transform.TransformDirection(Vector3.right * (MotorAcceleration * 0.1f) * m_MotorAirSpeedModifier) * m_SlopeFactor);

            // dampen motor force
            m_MotorThrottle.x /= (1.0f + (MotorDamping * m_MotorAirSpeedModifier * Time.timeScale));
            m_MotorThrottle.z /= (1.0f + (MotorDamping * m_MotorAirSpeedModifier * Time.timeScale));
        }
        /// <summary>
        /// this method calculates a controller velocity multiplier
        /// depending on ground slope. at 'MotorSlopeSpeed' 1.0,
        /// velocity in slopes will be kept roughly the same as on
        /// flat ground. values lower or higher than 1 will make the
        /// controller slow down / speed up, depending on whether
        /// we're moving uphill or downhill
        /// </summary>
        protected virtual void UpdateSlopeFactor()
        {

            if (!m_Grounded)
            {
                m_SlopeFactor = 1.0f;
                return;
            }

            // determine if we're moving uphill or downhill
            m_SlopeFactor = 1 + (1.0f - (Vector3.Angle(m_GroundHit.normal, m_MotorThrottle) / 90.0f));

            if (Mathf.Abs(1 - m_SlopeFactor) < 0.01f)
                m_SlopeFactor = 1.0f;       // standing still or moving on flat ground, or moving perpendicular to a slope
            else if (m_SlopeFactor > 1.0f)
            {
                // moving downhill
                if (MotorSlopeSpeedDown == 1.0f)
                {
                    // 1.0 means 'no change' so we'll alter the value to get
                    // roughly the same velocity as if ground was flat
                    m_SlopeFactor = 1.0f / m_SlopeFactor;
                    m_SlopeFactor *= 1.2f;
                }
                else
                    m_SlopeFactor *= MotorSlopeSpeedDown;   // apply user defined multiplier
            }
            else
            {
                // moving uphill
                if (MotorSlopeSpeedUp == 1.0f)
                {
                    // 1.0 means 'no change' so we'll alter the value to get
                    // roughly the same velocity as if ground was flat
                    m_SlopeFactor *= 1.2f;
                }
                else
                    m_SlopeFactor *= MotorSlopeSpeedUp; // apply user defined multiplier

                // kill motor if moving into a slope steeper than 'slopeLimit'. this serves
                // to prevent exploits with being able to walk up steep surfaces and walls
                m_SlopeFactor = (GroundAngle > Player.SlopeLimit.Get()) ? 0.0f : m_SlopeFactor;

            }

        }
        protected override void FixedMove()
        {

            // --- apply forces ---
            m_MoveDirection = Vector3.zero;
            //m_MoveDirection += m_ExternalForce;
            m_MoveDirection += m_MotorThrottle;
            //m_MoveDirection.y += m_FallSpeed;

            // --- apply anti-bump offset ---
            // this pushes the controller towards the ground to prevent the character
            // from "bumpety-bumping" when walking down slopes or stairs. the strength
            // of this effect is determined by the character controller's 'Step Offset'
            m_CurrentAntiBumpOffset = 0.0f;
            if (m_Grounded && m_MotorThrottle.y <= 0.001f)
            {
                m_CurrentAntiBumpOffset = Mathf.Max(Player.StepOffset.Get(), Vector3.Scale(m_MoveDirection, (Vector3.one - Vector3.up)).magnitude);
                m_MoveDirection += m_CurrentAntiBumpOffset * Vector3.down;
            }

            // --- predict move result ---
            // do some prediction in order to detect blocking and deflect forces on collision
            m_PredictedPos = Transform.position + fp_MathUtility.NaNSafeVector3(m_MoveDirection * Delta * Time.timeScale);

            // --- move the charactercontroller ---

            // ride along with movable objects
            //if (m_Platform != null && PositionOnPlatform != Vector3.zero)
            //	Player.Move.Send(vp_MathUtility.NaNSafeVector3(m_Platform.TransformPoint(PositionOnPlatform) -
            //															m_Transform.position));

            // move on our own
            Player.Move.Send(fp_MathUtility.NaNSafeVector3(m_MoveDirection * Delta * Time.timeScale));

            // while there is an active death event, block movement input
            if (Player.Dead.Active)
            {
                Player.InputMoveVector.Set(Vector2.zero);
                return;
            }

            // --- store ground info ---
            StoreGroundInfo();

            // --- store head contact info ---
            // spherecast upwards for some info on the surface touching the top of the collider, if any
            //if (!m_Grounded && (Player.Velocity.Get().y > 0.0f))
            //{
            //	Physics.SphereCast(new Ray(Transform.position, Vector3.up),
            //								Player.Radius.Get(), out m_CeilingHit,
            //								Player.Height.Get() - (Player.Radius.Get() - SkinWidth) + 0.01f,
            //								vp_Layer.Mask.ExternalBlockers);
            //	m_HeadContact = (m_CeilingHit.collider != null);
            //}
            //else
            //	m_HeadContact = false;

            // --- handle loss of grounding ---
            if ((m_GroundHitTransform == null) && (m_LastGroundHitTransform != null))
            {

                // if we lost contact with a moving object, inherit its speed
                // then forget about it
                //if (m_Platform != null && PositionOnPlatform != Vector3.zero)
                //{
                //	AddForce(m_Platform.position - m_LastPlatformPos);
                //	m_Platform = null;
                //}

                // undo anti-bump offset to make the fall smoother
                if (m_CurrentAntiBumpOffset != 0.0f)
                {
                    Player.Move.Send(fp_MathUtility.NaNSafeVector3(m_CurrentAntiBumpOffset * Vector3.up) * Delta * Time.timeScale);
                    m_PredictedPos += fp_MathUtility.NaNSafeVector3(m_CurrentAntiBumpOffset * Vector3.up) * Delta * Time.timeScale;
                    m_MoveDirection += m_CurrentAntiBumpOffset * Vector3.up;
                }

            }
        }
        /// <summary>
        /// since the controller is moved in FixedUpdate and the
        /// camera in Update there will be noticeable camera jitter.
        /// this method simulates the controller move in Update and
        /// stores the smooth position for the camera to read
        /// </summary>
        protected virtual void SmoothMove()
        {

            if (Time.timeScale == 0.0f)
                return;

            // restore last smoothpos
            m_FixedPosition = Transform.position;   // backup fixedpos
            Transform.position = m_SmoothPosition;

            // move controller to get the smooth position
            Player.Move.Send(fp_MathUtility.NaNSafeVector3((m_MoveDirection * Delta * Time.timeScale)));
            m_SmoothPosition = Transform.position;
            Transform.position = m_FixedPosition;   // restore fixedpos

            // reset smoothpos in these cases
            if ((Vector3.Distance(Transform.position, m_SmoothPosition) > Player.Radius.Get())) // smoothpos deviates too much
                                                                                                //|| (m_Platform != null) && ((m_LastPlatformPos != m_Platform.position)))        // we're on a platform thas is moving (causes jitter)
                m_SmoothPosition = Transform.position;

            // lerp smoothpos back to fixedpos slowly over time
            m_SmoothPosition = Vector3.Lerp(m_SmoothPosition, Transform.position, Time.deltaTime);

        }

        public override void SetPosition(Vector3 position)
        {

            base.SetPosition(position);
            m_SmoothPosition = position;

        }

        public override void Stop()
        {

            base.Stop();

            m_MotorThrottle = Vector3.zero;
            //	m_MotorJumpDone = true;
            //	m_MotorJumpForceAcc = 0.0f;
            //	m_ExternalForce = Vector3.zero;
            //	StopSoftForce();
            m_SmoothPosition = Transform.position;

        }
    }
}